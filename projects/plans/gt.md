# GT - Git Stacked PR Management Tool

## Project Description
A CLI tool for managing stacked pull requests similar to Graphite. Built with Go and Bubble Tea for interactive visualization. Core features include creating branch stacks, syncing after PR merges (rebase with master, delete merged branches, rebase upstream PRs), and visualizing stacks with an interactive TUI.

## Technical Architecture
- **Language**: Go (integrated with Bazel build system)
- **CLI Framework**: Cobra for command structure
- **TUI Framework**: Bubble Tea for interactive visualization
- **Git Integration**: Shell out to git commands via exec.Command
- **Config Storage**: JSON in .git/gt/config.json
- **Key Commands**: init, create, sync, stack (visualization), ls, up/down (navigation), status

## Stack Model
A stack is a linked list of git branches where each branch (except the first) has a parent branch. The first branch in a stack branches off master. When creating PRs, each branch's PR targets its parent branch, creating a stack of dependent PRs.

## Implementation Plan

- [ ] Set up gt project structure based on existing projects/git: Create projects/gt/ directory and copy structure from projects/git. Copy main.go and BUILD.bazel from projects/git to projects/gt, update binary name from "git" to "gt" in BUILD.bazel, update importpath to "github.com/ayush0624/monorepo/projects/gt", update root command Use/Short/Long in main.go to reflect gt tool. Create internal/ directory structure with subdirectories: internal/git, internal/stack, internal/config, internal/ui. Create cmd/ subdirectory for command implementations with stub files: cmd/init.go, cmd/create.go, cmd/sync.go, cmd/stack.go, cmd/submit.go, cmd/ls.go, cmd/up.go, cmd/down.go, cmd/status.go, cmd/continue.go, cmd/restack.go. Add Bubble Tea and Lipgloss dependencies to go.mod: run `go get github.com/charmbracelet/bubbletea@latest github.com/charmbracelet/lipgloss@latest` from monorepo root. Run `bazel run //:gazelle` to generate BUILD files for new packages. Test: Run `bazel build //projects/gt:gt` and verify it builds successfully, run `bazel run //projects/gt:gt` and verify the binary executes with Cobra help message. Verify gazelle generated BUILD files in internal/ subdirectories.

- [ ] Set up Cobra CLI framework and command structure: Update main.go to define root command and register all subcommands (init, create, sync, submit, stack, restack, continue, ls, up, down, status). Implement each command in its cmd/*.go file as a Cobra command with proper Use/Short/Long descriptions and help text. Each command should be a stub that prints "Command not implemented yet". Wire up all commands to rootCmd.AddCommand() in main.go. Add --verbose flag to root command for debug logging (will be implemented later). Add --version flag showing version info. Test: Run `bazel run //projects/gt:gt -- --help` and verify all 11 commands are listed with descriptions. Run each command stub and verify they execute and print stub message. Verify `gt --version` shows version. Verify `bazel run //:gazelle` updates BUILD files correctly after adding command files.

- [ ] Implement git operations wrapper package: Create internal/git/git.go with functions to execute git commands and parse output: GetCurrentBranch() returns current branch name, ListBranches() returns all local branches, GetBranchUpstream(branch) returns remote tracking branch, Rebase(branch, onto) rebases branch onto another, ForcePush(branch) force pushes with --force-with-lease, DeleteBranch(branch) deletes local branch, DeleteRemoteBranch(branch) deletes remote branch, GetMergeBase(branch1, branch2) finds common ancestor, IsMerged(branch, target) checks if branch is merged into target using merge-base --is-ancestor, BranchExists(branch) checks if branch exists locally, CheckoutBranch(branch) switches to branch, CreateBranch(branch, base) creates new branch from base, Fetch() fetches from origin, IsGitRepo() checks if current directory is in git repo, GetRemote() gets default remote name, IsDetachedHead() checks for detached HEAD state, HasGitConfig(key) checks if git config key exists. Use exec.Command("git", args...) and parse stdout/stderr. Return errors for non-zero exit codes with stderr output. Test: Create comprehensive unit tests in git_test.go that set up temporary git repositories with test data (using git init, git commit, etc.). Test each function with various scenarios: verify GetCurrentBranch returns correct branch, verify error handling when git command fails (non-zero exit), test in detached HEAD state, test when git config is missing (no remote configured), create branches and verify ListBranches, test rebase with clean and conflict scenarios, test IsMerged with various merge states, test branch deletion, verify error messages include stderr output. Run tests with `bazel test //projects/gt/internal/git:git_test`.

- [ ] Design and implement stack data structure with parent-child relationships: Create internal/stack/stack.go with types: Branch struct (Name string, Parent string, CommitSHA string), Stack struct (Name string, Branches []Branch, Root string). Implement methods: NewStack(name, rootBranch) creates new stack, AddBranch(branch, parent) adds branch to stack maintaining parent-child relationship, RemoveBranch(branch) removes branch and updates children to point to removed branch's parent, GetBranches() returns ordered list from root to leaves, GetUpstream(branch) returns all branches that depend on this branch (children, grandchildren, etc.), FindBranch(name) returns branch if exists in stack, GetParent(branch) returns parent branch, IsInStack(branch) checks if branch is part of stack. Validate that parent exists before adding branch. Test: Create unit tests in stack_test.go with table-driven tests. Test: creating stacks, adding branches in sequence, removing middle branches and verifying children are relinked correctly, getting upstream branches for various positions in stack, finding branches, testing edge cases (removing root, adding to non-existent parent, circular dependencies). Run `bazel test //projects/gt/internal/stack:stack_test`.

- [ ] Implement configuration persistence layer for storing stacks: Create internal/config/config.go with Config struct containing map of stack names to Stack objects. Implement: InitConfig() creates .git/gt/ directory and empty config.json if not exists, LoadConfig() reads and unmarshals config.json into Config struct, SaveConfig(config) marshals and writes Config to config.json with file locking using flock (create .git/gt/config.lock), GetStack(name) retrieves stack by name, AddStack(stack) adds new stack to config, UpdateStack(stack) updates existing stack, DeleteStack(name) removes stack from config, GetAllStacks() returns all stacks, ConfigExists() checks if gt is initialized. Use JSON encoding with proper indentation for readability. Implement file locking: acquire lock before read/write, release after operation, timeout after 5 seconds if lock cannot be acquired. Add ValidateStackIntegrity() that checks if git branches referenced in config still exist and warns if they don't. Test: Create tests in config_test.go using temporary directories. Test: init creates directory and file, save and load round-trip preserves data, adding/updating/deleting stacks works correctly, loading non-existent config returns appropriate error, verify JSON format is valid and readable, test with multiple stacks containing multiple branches, test concurrent access with goroutines to verify locking works. Run `bazel test //projects/gt/internal/config:config_test`.

- [ ] Implement 'gt init' command to initialize gt in a repository: Wire up init command in cmd/init.go. Check if current directory is in a git repository using git.IsGitRepo(), if not return error with message "Not in a git repository". Check if .git/gt already exists using config.ConfigExists(), if yes print "gt is already initialized" and exit successfully (idempotent). Call config.InitConfig() to create .git/gt/config.json with empty stacks map. Print success message "Initialized gt in this repository". Test: Create a test git repository in temp directory, run `bazel run //projects/gt:gt -- init` and verify .git/gt/config.json is created and contains empty config. Run init again and verify it reports already initialized without error. Create temp directory without git and run init, verify it exits with appropriate error message. Verify error code is non-zero on failure, zero on success.

- [ ] Implement 'gt create' command for creating new branches and stacks: Wire up create command in cmd/create.go with signature `gt create <branch-name> [--parent <parent-branch>]`. Load config using config.LoadConfig(). If --parent is not specified: create new stack with stack name same as branch name, create git branch from master using git.CreateBranch(), add branch to stack as root, save config, checkout new branch, print "Created new stack '<stack-name>' with branch '<branch-name>'". If --parent is specified: find stack containing parent branch, verify parent exists in git and in stack, create git branch from parent using git.CreateBranch(), add branch to stack with parent relationship using stack.AddBranch(), save config, checkout new branch, print "Created branch '<branch-name>' in stack '<stack-name>' based on '<parent-branch>'". Test: Create test git repo with master branch. Run `gt init`, then `gt create feature-1` and verify: git branch exists, config contains new stack with feature-1 as root, feature-1 is checked out. Run `gt create feature-2 --parent feature-1` and verify: git branch exists, feature-2 is in same stack as feature-1 with correct parent, feature-2 is checked out. Test error cases: creating branch with existing name, specifying non-existent parent, running without init first. Run `bazel test //projects/gt/cmd:create_test`.

- [ ] Implement 'gt submit' command for creating and updating GitHub PRs: Wire up submit command in cmd/submit.go with signature `gt submit [branch-name]`. If branch-name not specified, use current branch. Verify gh CLI is installed by running exec.Command("gh", "--version"), if not found print error "gh CLI is required for gt submit. Install from https://cli.github.com/". Load config and find stack containing specified branch. For each branch in stack from root to current branch (inclusive): check if PR already exists using `gh pr list --head <branch> --json number,url -q '.[0].number'`. If no PR exists: determine base branch (root branch uses master, other branches use their parent), generate PR title from latest commit message on branch, generate PR body including stack visualization showing this branch's position in stack (e.g., "Stack: feature\n  ├─ feature-1 (master) #123\n  ├─ feature-2 (feature-1) #124\n  └─ feature-3 (feature-2) <- this PR"), create PR using `gh pr create --base <base> --head <branch> --title <title> --body <body>`, print "Created PR #<number> for <branch> -> <base>: <url>". If PR exists: update PR body with current stack visualization using `gh pr edit <number> --body <body>`, print "Updated PR #<number> for <branch>: <url>". After all PRs created/updated, print summary with all PR URLs. Test: Create test repo with stack of 3 branches, mock gh CLI or use real GitHub test repo, run `gt submit` and verify 3 PRs are created with correct base branches (feature-1 -> master, feature-2 -> feature-1, feature-3 -> feature-2), verify stack visualization in PR body. Run submit again and verify PRs are updated not recreated. Test error: gh not installed, not in a stack. Run `bazel test //projects/gt/cmd:submit_test`.

- [ ] Implement 'gt stack' command for text-based stack visualization: Wire up stack command in cmd/stack.go. Load config and get all stacks. For current implementation (before TUI), display each stack in text format: print stack name as header, iterate through branches in order from root to leaves using stack.GetBranches(), for each branch print with indentation showing depth (root has no indent, children indented with "  "), show branch name and mark current branch with "*", show latest commit message from git log --oneline -1 <branch>. Format example: "Stack: feature\n  feature-1 [abc123] Initial feature\n    * feature-2 [def456] Add validation\n      feature-3 [ghi789] Add tests". If no stacks exist, print "No stacks found. Create one with 'gt create <branch-name>'". Test: Create test repo with multiple stacks and branches. Run `gt stack` and verify output shows all stacks correctly formatted with proper indentation and current branch marker. Test with no stacks, single stack, multiple stacks, deeply nested stacks. Verify commit messages are shown correctly. Run `bazel test //projects/gt/cmd:stack_test`.

- [ ] Implement Bubble Tea TUI for interactive stack visualization: Create internal/ui/stack_view.go using Bubble Tea framework. Create model struct with: stacks []Stack, selectedStack int, selectedBranch int, currentBranch string. Implement Bubble Tea interface: Init() initializes model, Update() handles keyboard input (up/down arrows to navigate, left/right to change stack, q to quit, enter to checkout branch), View() renders the UI. Use lipgloss for styling: highlight current branch in different color, show selected item with background color, use box drawing characters for tree structure (├─, └─, │). Show stack names as headers, branches as tree with parent-child relationships visible, commit SHAs and messages for each branch. Add help text at bottom showing keybindings. Wire into stack command with default behavior (or --interactive flag). Test: Create test repo with sample stacks, run `gt stack` and verify TUI launches. Test keyboard navigation: verify arrow keys move selection, verify q quits cleanly, verify enter checks out selected branch (if implemented), verify tree structure displays correctly with proper branching characters. Test edge cases: empty repo, single branch, wide tree (many children), deep tree (many levels). Manually test rendering in terminal. Create unit tests for model Update logic. Run `bazel test //projects/gt/internal/ui:stack_view_test`.

- [ ] Implement 'gt sync' command part 1 - detect merged branches: Wire up sync command in cmd/sync.go. Load config and determine current stack by finding stack containing current branch. Call git.Fetch() to get latest from origin. For each branch in current stack starting from root: check if branch is merged to master using git log master --format=%H | grep $(git rev-parse <branch>) or by checking if git merge-base --is-ancestor <branch> master returns true. Alternatively, if gh CLI is available (check with exec.Command("gh", "--version")), use `gh pr list --head <branch> --state merged --json number` to check PR merge status. Collect all merged branches in a list. Print "Detected merged branches: <branch1>, <branch2>". If no merged branches found, print "No merged branches detected" and exit. For now, just detect and print; don't delete yet. Test: Create test repo with master and a stack of 3 branches. Manually merge the first branch into master with `git checkout master && git merge feature-1`. Run `gt sync` and verify it detects feature-1 as merged. Test with multiple merged branches, verify all are detected. Test with no merged branches. Test error handling when not in a git repo or gt not initialized. Run `bazel test //projects/gt/cmd:sync_test`.

- [ ] Implement 'gt sync' command part 2 - cleanup and rebase workflow: Complete sync command to perform full sync operation. Save original branch to return to later. After detecting merged branches, for each merged branch in order: delete local branch using git.DeleteBranch(), attempt to delete remote branch using git.DeleteRemoteBranch() (ignore error if remote doesn't exist), remove branch from stack using stack.RemoveBranch(). After all deletions, save config once. After cleanup, rebase remaining branches: For each remaining branch, calculate its new base by tracing back through parents - if direct parent still exists in stack use that, otherwise trace back through deleted parents until finding an existing parent or reaching root (use master). If root branch was deleted, all remaining branches should rebase onto master. For each branch in order from root to leaves: checkout branch, run git.Rebase(newBase), if rebase succeeds run git.ForcePush(branch) to update remote, if rebase fails with conflicts: save sync state to .git/gt/sync_state.json including list of remaining branches to rebase and their target bases, print error "Rebase conflict on <branch>. Resolve conflicts manually, then run 'git rebase --continue' followed by 'gt continue' to resume", exit with error code 1. After all rebases complete successfully: if stack has no remaining branches, delete stack from config using config.DeleteStack() and print "Stack '<name>' fully merged and removed", otherwise print "Sync complete. Deleted <N> merged branches and rebased <M> branches". Return to original branch if it still exists, otherwise checkout master. Test: Create complex test scenario with stack of 4 branches, merge first 2 into master, run sync and verify: merged branches are deleted locally and remotely and from config, remaining branches are rebased onto correct new base (feature-3 rebases onto master, feature-4 rebases onto feature-3), branches are force-pushed, config is updated correctly. Test conflict scenario: create merge conflict, run sync, verify it saves state and stops with helpful message. Test edge case: all branches merged, verify stack is deleted from config and message printed. Test root deletion: merge root, verify remaining branches rebase onto master. Run `bazel test //projects/gt/cmd:sync_test`.

- [ ] Implement 'gt continue' command for resuming after rebase conflicts: Wire up continue command in cmd/continue.go. Check if either sync state file exists at .git/gt/sync_state.json or restack state file exists at .git/gt/restack_state.json. If neither exists, print "No sync or restack in progress" and exit. Load the state file that exists (sync or restack) including list of remaining branches to rebase and their target bases, and original branch to return to. Check current git status with `git status --porcelain`, if output contains "rebase in progress" or unmerged paths, print error "Rebase still has conflicts or is not complete. Run 'git rebase --continue' first, then try 'gt continue' again". If git status is clean, verify last rebase completed successfully. Force-push the current branch with git.ForcePush() to update remote after resolved rebase. Continue rebasing remaining branches from saved state: for each remaining branch, checkout and rebase onto its saved target base, if rebase succeeds force-push, if rebase fails with conflicts update state file removing completed branches and exit with error (same as sync/restack). When all branches complete successfully, delete state file, print "Continue complete. Rebased remaining <N> branches", return to original branch if it still exists. Test: Create stack, start sync that encounters conflict on second branch of 4, manually resolve conflict and run `git rebase --continue`, run `gt continue` and verify it force-pushes resolved branch and continues rebasing remaining 2 branches. Test same scenario with restack. Test error cases: running continue with no state file, running continue while rebase still in progress with conflicts. Verify state file is deleted after successful completion. Run `bazel test //projects/gt/cmd:continue_test`.

- [ ] Implement 'gt restack' command for rebasing stack without sync: Wire up restack command in cmd/restack.go. This command rebases entire stack onto latest master without detecting or deleting merged branches. Call git.Fetch() to get latest from origin. Checkout master and pull latest with `git pull origin master`. Load config and determine current stack by finding stack containing current branch. Save original branch to return to later. For each branch in stack from root to leaves: determine base (root rebases onto master, other branches rebase onto their parent), checkout branch, run git.Rebase(base), if rebase succeeds run git.ForcePush(branch) to update remote, if rebase fails with conflicts: save restack state to .git/gt/restack_state.json including remaining branches and their bases, print error "Rebase conflict on <branch>. Resolve conflicts manually, then run 'git rebase --continue' followed by 'gt continue' to resume", exit with error code 1 (gt continue will detect restack state instead of sync state). After all rebases complete successfully, print "Restack complete. Rebased <N> branches onto latest master". Return to original branch. Test: Create stack with 3 branches, make new commits to master, run `gt restack` and verify all branches are rebased onto new master with correct parent relationships maintained, verify branches are force-pushed. Test conflict scenario: create conflict, verify state is saved and helpful error shown. Test that gt continue works with restack state. Run `bazel test //projects/gt/cmd:restack_test`.

- [ ] Add comprehensive error handling, validation, and logging: Review all commands and packages, add error handling for all git operations, file operations, and user inputs. Validate: branch names match git requirements (no spaces, special chars), stack names are valid, parent branches exist before creating children, current directory is git repo before any git operations, gt is initialized before running commands that need config. Add custom error types for common scenarios: ErrNotInGitRepo, ErrNotInitialized, ErrBranchNotFound, ErrStackNotFound, ErrInvalidBranchName. Add --verbose flag implementation to root command that enables debug logging using log package, show git commands being executed, show config file operations, show stack operations. Ensure all errors are returned up the call stack and printed with helpful context at command level. Format error messages with suggestions: "Branch 'foo' not found. Create it with 'gt create foo'". Test: Create test cases for each error condition in each package. Run commands with invalid inputs and verify helpful error messages. Verify exit codes are correct (0 for success, non-zero for errors). Test verbose flag shows debug output. Run `bazel test //projects/gt/... ` and verify all tests pass.

- [ ] Create integration tests and verify code coverage: Add integration test directory at projects/gt/tests/ with comprehensive workflow tests: test_create_stack_workflow creates temp repo, inits gt, creates stack with 3 branches using gt create, verifies git branch state and config.json state match expectations; test_sync_workflow creates stack, manually merges first branch to master, runs gt sync, verifies merged branch deleted and remaining branches rebased correctly; test_submit_workflow creates stack, runs gt submit (with mocked gh CLI), verifies PR creation with correct base branches; test_restack_workflow creates stack, adds commits to master, runs gt restack, verifies all branches rebased; test_navigation_workflow tests gt up/down/status commands with various stack configurations; test_continue_workflow tests conflict resolution with gt sync and gt continue. Use table-driven tests in unit tests for edge cases and error conditions. Add code coverage reporting with go test -cover. Test: Run `bazel test //projects/gt/...` and verify all integration tests pass. Verify unit test coverage is >70% for all packages (internal/git, internal/stack, internal/config should be >80%). Use `go test -coverprofile=coverage.out ./...` to generate coverage report. Run `bazel run //:autofix` to ensure all code passes linting and formatting.

- [ ] Create comprehensive documentation: Create README.md in projects/gt/ with sections: project overview (what gt is and why it's useful), installation instructions (using Bazel: `bazel build //projects/gt:gt` and add to PATH), prerequisites (git, gh CLI for submit command), quick start guide with example workflow showing init -> create -> submit -> sync, complete command reference documenting all 11 commands with their flags and arguments, architecture overview explaining stack model and config storage in .git/gt/, troubleshooting section for common issues (conflicts, gh CLI not found, not in a stack), development setup instructions for contributors. Add godoc comments to all exported functions, types, and packages following Go conventions. Add inline code comments for complex logic especially in sync/restack/continue rebase workflows and stack parent-child relationship management. Create CONTRIBUTING.md with guidelines for: setting up development environment, running tests, code style (defer to gofmt and ruff), submitting PRs, adding new commands. Test: Run through all README examples manually in a fresh test repository to ensure they work exactly as documented. Verify `go doc` renders documentation correctly for all packages. Verify README renders properly on GitHub (check markdown formatting, code blocks, links). Run `bazel run //:autofix` one final time.

- [ ] Implement additional navigation and utility commands: Add 'gt ls' command in cmd/ls.go to list all stacks and their branches in simple text format (non-interactive): print each stack name with branch count, add --verbose flag to show all branches in each stack with indentation. Add 'gt up' command in cmd/up.go to checkout parent branch: load current branch, find its stack and parent using stack.GetParent(), if no parent exists (at root) print "Already at root of stack" and exit, checkout parent with git.CheckoutBranch(), print "Checked out <parent-branch> (parent of <current-branch>)". Add 'gt down' command in cmd/down.go to checkout child branch: find children of current branch, if no children print "No child branches" and exit, if exactly one child checkout that child, if multiple children exist show interactive selection menu using simple numbered list with fmt.Scanf for input (example: "1. feature-2\n2. feature-3\nSelect branch [1-2]: "), checkout selected child branch, print "Checked out <child-branch> (child of <current-branch>)". Add 'gt status' command in cmd/status.go to show current position in stack: print current branch name, print stack name it belongs to or "Not in a stack" if not found, print parent branch if exists, print children branches if any, if gh CLI available check PR status with `gh pr list --head <current-branch> --json state,number,url -q '.[0]'` and print PR state (open/draft/merged) with number and URL, show position like "Branch 2 of 4 in stack". Test: Create test repo with multiple stacks. Test `gt ls` shows all stacks with counts, test `gt ls --verbose` shows all branches. Create a stack with 3 branches, checkout middle branch, run `gt up` and verify it checks out parent, run `gt down` and verify it checks out child. Create branch with multiple children, run `gt down` and verify interactive selection appears. Run `gt status` and verify it shows correct position and relationships. Test edge cases: up at root shows message, down at leaf shows message, down with multiple children shows selection, status outside stack shows appropriate message. Run `bazel test //projects/gt/cmd:navigation_test`.
